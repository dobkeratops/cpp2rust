#ifndef ast_h
#define ast_h

#include "cpp2rustcommon.h"
#include "clanghelpers.h"

struct VisitorData {
	int depth;
};

/*
enum AstNodeId {
	AST_UNKNOWN, AST_STRUCT,AST_FUNCTION,AST_METHOD,AST_PARAM,AST_FIELD,AST_NAMESPACE,AST_NUM
};
const char* g_AstNodeNames[]= {
	"?", "struct","function","method","param","field","namespace"
};
*/

typedef enum CXCursorKind CXCursorKind;
struct AstNode;
typedef const AstNode* CpAstNode;
typedef AstNode* PAstNode;

// AST Node the info extracted from a CXCursor - its a copy of a subset of the
// ast organized for this task
struct AstNode {
	
	AstNode*	parent;
	CXCursorKind	nodeKind;
	string name;
	string typeName;
	///TODO mutable string	rustName;	// translated, overload resolution
	CXType	cxType;
	CXType	resultType;	// why need 2, todo: union/access one or the other. cxType is just 'functoinProto'
	vector<AstNode>	subNodes;	
	AstNode() {};
	AstNode(AstNode* parentNode,const CXCursorKind k, const char* n,const char* tn, CXType cxt,CXType returnType) {
		this->parent=parentNode;
		this->nodeKind=k; this->name=n; this->typeName=tn; this->cxType=cxt; this->resultType=returnType;
	}
    string getName() const { return this->name;}
	string& getNameRef() { return this->name;}
	pair<string,int32_t> getFoo() { return make_pair(this->name,2);}

	AstNode*	createSubNode(CXCursorKind k, const char* name, const char* typeName, CXType cxt, CXType result) {
		this->subNodes.emplace_back(this,k,name,typeName,cxt,result);
		return (AstNode*)&(this->subNodes.back());
	}
	template<typename T> fn append(T* parent,vector<T>& vec,//AstNodeId id, 
								CXCursorKind k,
								const char* name)->T* { 
		int len=vec.size();
		vec.resize(len+1);
		auto newItem=&vec[len];
	//	newItem->nodeType = id;
		newItem->parent=parent;
		newItem->nodeKind = k;
		newItem->name = name;
		return	newItem;
	}

	template<typename F>
	fn visit(F& f) const->void { for (auto &sn:subNodes) f(sn);}
	fn is(CXCursorKind k)const->bool {return nodeKind==k;}
	fn is2(CXCursorKind k0,CXCursorKind k1)const->bool {return nodeKind==k0||nodeKind==k1;}
	fn is3(CXCursorKind k0,CXCursorKind k1,CXCursorKind k2)const->bool {return nodeKind==k0||nodeKind==k1||nodeKind==k2;}

	fn getSubOfType(CXCursorKind k)->PAstNode {
		for(auto& s:subNodes)
			if (s.nodeKind==k)
				return &s;
		return nullptr;
	}
	template<typename F>
	fn filter(F& f,vector<const AstNode*>& results) ->void {
		for (auto& s:subNodes)
			if (f(s)) results.push_back(&s);
	}
	template<typename F>
	fn filter(F& f,vector<const AstNode*>& results) const->void {
		for (auto& s:subNodes)
			if (f(s)) results.push_back(&s);
	}
	template<typename T>
	fn filterByKind( CXCursorKind k, vector<T>& results)->void {
		for (auto& s:subNodes)
			if (s.nodeKind==k)
				results.push_back(&s);
	}
	template<typename T>
	fn filterByKind( CXCursorKind k, vector<T>& results) const->void {
		for (auto& s:subNodes)
			if (s.nodeKind==k)
				results.push_back(&s);
	}

	fn filterByKindRec( CXCursorKind k, vector<CpAstNode>& results) const->void;
	fn filterByKindMut( CXCursorKind k, vector<PAstNode>& results)->void;

	template<typename F>
	fn filterIndexed(const F& f, vector<const AstNode*>& results, vector<int32_t>& resultIndices) const->void {
		int	index=0;
		for (auto& s:subNodes) {
			if (f(&s)) {results.push_back(&s); resultIndices.push_back(index);}
			index++;
		}
	}
	fn cname() const->pconstchar_t { return this->name.c_str();}
	// generated by rule in makefile from .cpp
	// "_mf"=member-functions.
	fn findFirstSub(CXCursorKind k,bool rec) const->CpAstNode;
	fn findFirst(CXCursorKind k) const->CpAstNode;
	fn findFirstRec(CXCursorKind k) const->CpAstNode;
	fn count(CXCursorKind k) const->int32_t;

	void findModClasses(vector<pair<CpAstNode,CpAstNode>>& results) const;
	fn numTemplateParams() const ->int32_t;

//	#include "AstNode.hxx"
};
#include "ast_fn.hxx"
#endif
